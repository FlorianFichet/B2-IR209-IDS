\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[french]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=3cm,left=2cm,right=2cm,marginparwidth=2cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\PassOptionsToPackage{hyphens}{url}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{fourier-orns}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{float}
\pagestyle{fancy} 
\setcounter{tocdepth}{5}

%% Tikz stuff
\usepackage{tikz}
\usetikzlibrary{calc, arrows}
\tikzstyle{incolore} = [rectangle, rounded corners, draw=black, minimum height=1cm, minimum width=3cm, text width=3cm, text centered]

\usepackage{libertine}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\renewcommand{\headrulewidth}{1pt}
\fancyhead[C]{}
\fancyhead[L]{}
\fancyhead[R]{\footnotesize{\leftmark}}

\renewcommand{\footrulewidth}{1pt}
\fancyfoot[C]{}
\fancyhead[L]{}
\fancyfoot[R]{\thepage}

\definecolor{Zgris}{rgb}{0.87,0.85,0.85}

\usepackage{eso-pic,graphicx}
\usepackage{xcolor}
\newcommand{\bgimg}[1]
{
    \AddToShipoutPicture
    {
        \put(\LenToUnit{0 cm},\LenToUnit{0 cm})
        {
            \includegraphics[width=\paperwidth,height=\paperheight]{#1}
        }
    }
}

\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}

\lstdefinestyle{CStyle}{
    commentstyle=\color{mGreen},
    keywordstyle=\color{red},
    numberstyle=\color{gray},
    stringstyle=\color{purple},
    frame=single,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C
}

\begin{document}





\begin{titlepage}
    \begin{sffamily}
        \begin{center}

            \includegraphics[width=5cm]{images/LogoHenallux.PNG}~\\[1.5cm]
            \textsc{\Large Rapport de projet}\\[1.5cm]

            \HRule \\[0.4cm]
            { \huge \bfseries Implémentation d'un IDS \\[0.4cm] }
            \HRule \\[2cm]

            \begin{minipage}{0.4\textwidth}
                \begin{flushleft} \large
                    Grégoire Roumache\\
                    Florian Fichet\\
                \end{flushleft}
            \end{minipage}
            \begin{minipage}{0.55\textwidth}
                \begin{flushright} \large
                    Développement -- Sécurité des systèmes\\
                    Deuxième année, groupe C-2 \\
                    Année académique 2020-2021\\
                \end{flushright}
            \end{minipage}
            \vfill

            {\large 3 Janvier 2021}

        \end{center}
    \end{sffamily}
\end{titlepage}

\let\cleardoublepage\clearpage










\section{Introduction}



Pour le cours de Développement, nous avons dû implémenter un IDS (Intrusion Detection System) qui analyse le trafic qui passe par une interface réseau de la machine. Il permet de détecter des activités suspectes en fonction d'un certain nombre de règles données au préalable. En cas d'anomalie, le programme peut alerter l'utilisateur en la signalant dans les logs du système.

Nous nous sommes organisés en utilisant la plateforme github, comme recommandé, et voici le lien vers notre répertoire: 
\begin{center}
    {\small \url{https://github.com/groumache/Intrusion-Detection-System}}
\end{center}










\section{Organisation du travail et configuration des outils}





\subsection{Les issues sur github}



Les issues sont utilisées pour s'organiser et garder une trace des tâches, des améliorations et des bugs dans un projet sur github.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\linewidth]{../markdown-explanations/images/issue-1.PNG}
    \caption{Une issue sur github}
    \label{fig:issue01}
\end{figure}
Explication de la figure \ref{fig:issue01}:
\begin{enumerate}
    \item Titre de l'issue.
    \item Explication/description de l'issue.
    \item On peut attribuer une issue à des personnes qui seront responsables pour résoudre l'issue.
    \item Le projet dans lequel l'issue va apparaître.
\end{enumerate}





\subsection{Utilisation du kanban sur github}



Comme nous l'avons précisé dans l'introduction, nous nous sommes organisés en utilisant github. Nous n'avons pas seulement mis le code sur github mais aussi utilisé le tableau kanban avec 4 sections:
\begin{enumerate}
    \item \textbf{Ideas}: un endroit pour ajouter des notes/issues qui dépassent les exigences du projet.
    \item \textbf{To do}: un endroit où les issues sont placées quand elles sont créées (correspond aux critères minimum de réussite).
    \item \textbf{In progress}: l'endroit où les issues vont quand on travaille dessus.
    \item \textbf{Done}: là où les issues vont quand elles sont fermées ou la pull request liée a été fusionnée.
\end{enumerate}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\linewidth]{../markdown-explanations/images/project-1.PNG}
    \caption{Kanban sur github}
\end{figure}

Sur le schéma de la figure \ref{fig:networkgraph}, on voit le network graph. Cette image illustre bien comment nous avons travaillé, c-à-d en créant des nouvelles branches à chaque fois que nous avons eu besoin de résoudre une issue. Une fois que le code a été ajouté, nous avons fait des pull requests pour fusionner les branches.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\linewidth]{../markdown-explanations/images/project-2.PNG}
    \caption{Network graph montrant les commits et comment les branches se rejoignent}
    \label{fig:networkgraph}
\end{figure}





\subsection{Configuration du debugger}



Les fichiers de configurations sont présentés sur les figures \ref{fig:debugconfig1} et \ref{fig:debugconfig2}.
\begin{enumerate}
    \item Sur la figure \ref{fig:debugconfig1}, on voit le fichier \textit{tasks.json} où on configure la compilation du projet:
    \begin{itemize}
        \item on voit que le paramètre \textit{command} donne bien le compilateur gcc,
        \item les arguments sont précisés par le paramètre \textit{args}, ce sont ceux recommandés dans l'énoncé,
        \item si on combine le tout, c'est l'équivalent de la commande:
        \begin{center}
            \texttt{\small gcc -Wall -o ids main.c populate.c rules.c -lpcap}
        \end{center}
    \end{itemize}
    \item Sur la figure \ref{fig:debugconfig2}, on voit le fichier \textit{launch.json}, il sert à configurer le lancement du programme:
    \begin{itemize}
        \item dans \textit{program}, on voit qu'on a bien précisé \textit{ids},
        \item et dans \textit{args}, on voit les arguments du programme.
        \item si on combine le tout, c'est l'équivalent de la commande:
        \begin{center}
            \texttt{\small ids -p -d eth1 -r ids.rules -n 10}
        \end{center}
    \end{itemize}
\end{enumerate}
Remarquez qu'il faut lancer le programme avec des privilèges plus élevé que l'utilisateur standard. Pour réussir à faire cela, on peut lancer visual studio code avec ces mêmes privilèges.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{images/task-json.PNG}
    \caption{Fichier de configuration du debugger, pour la compilation du programme}
    \label{fig:debugconfig1}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.70\linewidth]{images/launch-json.PNG}
    \caption{Fichiers de configuration du debugger, pour lancer le programme}
    \label{fig:debugconfig2}
\end{figure}





\subsection{Utilisation de valgrind}



Valgrind est un outil de programmation qui sert principalement à découvrir des fuites de mémoire. Par exemple, si nous allouons un bloc de mémoire dans le tas (heap) et que nous ne le libèrons pas, valgrind va nous rappeler à l'ordre et même nous dire à quelle ligne le bloc mémoire à été alloué (si le programme a été compilé avec un debug flag).

Lancement du programme avec valgrind (rappel: ids doit être lancé avec des privilèges):
{\small \begin{verbatim}
    valgrind --leak-check=full \
        --show-leak-kinds=all \
        --track-origins=yes \
        --verbose \
        ./ids
\end{verbatim}}

L'objectif est donc d'obtenir un résultat comme celui à la figure \ref{fig:valgrind}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{../markdown-explanations/images/valgrind-01.PNG}
    \caption{Résultat de valgrind}
    \label{fig:valgrind}
\end{figure}





\subsection{Configuration du formatage automatique}



L'extension C/C++ de visual studio code nous permet de faire du formatage automatique de notre code comme illustré par la figure \ref{fig:formatting}. La configuration se fait au en suivant la syntaxe clang-format, voici celle que nous avons utilisé:

{\small\begin{verbatim}
{
    BasedOnStyle: Google,
    IndentWidth: 4,
    MaxEmptyLinesToKeep: 2,
    IndentPPDirectives: BeforeHash
}
\end{verbatim}}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\linewidth]{../markdown-explanations/images/setup-04.PNG}
    \caption{Paramètre de formatage dans visual studio code}
    \label{fig:formatting}
\end{figure}










\section{Architecture du projet}





\subsection{Architecture du système}



Comme on peut voir sur la figure \ref{fig:archsys}, l'ids est divisé en quatre parties logiques.
\begin{enumerate}
    \item \textit{read\_rules}: cette partie est responsable d'extraire les règles du fichier pour les mettre dans les structures appropriées
    \item \textit{populate\_packet}: cette partie doit extraire le paquet pour le placer dans les structures appropriées
    \item \textit{main}: cette partie a 4 responsabilités:
    \begin{itemize}
        \item analyse les arguments du programme
        \item faire appel aux parties \textit{read\_rules}, et \textit{populate\_packet}
        \item vérifier si les packets correspondent aux règles
        \item si ils correspondent aux règles, elle doit écrire un message dans syslog
    \end{itemize}
\end{enumerate}

\begin{figure}[H]
    \includegraphics[width=0.99\linewidth]{../markdown-explanations/images/software-architecture-2.png}
    \caption{Architecture du système}
    \label{fig:archsys}
\end{figure}





\subsection{Structure du projet}



Pour mieux comprendre l'organisation du projet, on peut regarder la figure \ref{fig:structproj} sert à montrer quels fichiers sont inclus dans quels autres.

\begin{figure}[H]
    \includegraphics[width=0.99\linewidth]{../markdown-explanations/images/project-structure.png}
    \caption{Structure du projet}
    \label{fig:structproj}
\end{figure}










\section{Organisation générale du code}



Dans cette section, nous allons expliquer comment le code fonctionne de manière générale mais sans entrer dans le détail. Les choix d'implémentation spécifiques seront expliqués dans la section suivante (section \ref{sec:implspec}).





\subsection{Fichier \textit{populate.c}}



Les 3 fonctions de ce fichier qui ont leur définition dans le header \textit{populate.h} sont:
\begin{itemize}
    \item \textit{populate\_packet}, organise les informations à partir de la trame brute
    \item \textit{print\_packet\_headers}, affiche les headers des protocols utilisés dans le paquet
    \item \textit{print\_packet\_data}, affiche les données contenues dans le protocole de dernière couche (HTTP, TLS, TCP ou UDP)
\end{itemize}
La fonction la plus importante de ce fichier est évidemment la fonction \textit{populate\_packet} qui va appeler d'autres fonctions \textit{populate} comme représenté sur la figure \ref{fig:orgpopulate}.
\begin{figure}[H]
    \centering
    \begin{tikzpicture}

        \node (packet) [incolore] at (0,0) {\textit{populate packet}};

        \node (datalink) [incolore] at (-6,-2) {\textit{populate data link}};
        \node (network) [incolore] at (-2,-2) {\textit{populate network}};
        \node (transport) [incolore] at (2,-2) {\textit{populate transport}};
        \node (application) [incolore] at (6,-2) {\textit{populate application}};

        \node (tcp) [incolore] at (0,-4) {populate tcp};
        \node (udp) [incolore] at (4,-4) {populate udp};

        \draw[->] (packet) -- (datalink);
        \draw[->] (packet) -- (network);
        \draw[->] (packet) -- (transport);
        \draw[->] (packet) -- (application);

        \draw[->] (transport) -- (tcp);
        \draw[->] (transport) -- (udp);

    \end{tikzpicture}
    \caption{Organisation des fonctions \textit{populate}}
    \label{fig:orgpopulate}
\end{figure}





\subsection{Fichier \textit{rules.c}}



Les fonctions de ce fichier qui ont leur définition dans le header \textit{rules.h} sont:
\begin{itemize}
    \item \textit{read\_rules}
    \item \textit{free\_rules}
\end{itemize}
La fonction la plus importante de ce fichier est \textit{read\_rules} qui va faire la tokenisation du fichier de règles (voir section \ref{subsec:tokens} pour des explications sur les tokens) puis en extraire les règles, ceci est illustré par la figure \ref{fig:orgrules}.
\begin{figure}[H]
    \centering
    \begin{tikzpicture}

        \node (read) [incolore] at (0,0) {\textit{read rules}};

        \node (token) [incolore] at (-4,-2) {\textit{tokenize rules}};
        \node (extract) [incolore] at (4,-2) {\textit{extract rules}};

        \node (action) [incolore] at (-6,-4) {\textit{get action}};
        \node (protocol) [incolore] at (-2,-4) {\textit{get protocol}};
        \node (dots) [incolore] at (2,-4) {\textit{...}};
        \node (options) [incolore] at (6,-4) {\textit{get options}};

        \node (settings) [incolore] at (6,-6) {\textit{get option settings}};

        \draw[->] (read) -- (token);
        \draw[->] (read) -- (extract);

        \draw[->] (extract) -- (action);
        \draw[->] (extract) -- (protocol);
        \draw[->] (extract) -- (dots);
        \draw[->] (extract) -- (options);

        \draw[->] (options) -- (settings);

    \end{tikzpicture}
    \caption{Organisation des fonctions utilisées pour extraire les règles}
    \label{fig:orgrules}
\end{figure}

Les fonctions pour obtenir les IPs et les ports sont plus compliquées parce que nous avons suivi le format de règle de \textit{surricata} \cite{2}. Ces formats sont représentés sur les figures \ref{fig:formatip} et \ref{fig:formatport}.
\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|} \hline
        \textbf{Opérateur} & \textbf{Description} \\ \hline
        ../.. & range d'IPs (notation CIDR) \\
        ! & exception/négation \\
        $[$.., ..$]$ & groupement \\ \hline
    \end{tabular}
    \caption{Format d'IP acceptable dans le fichier de règles}
    \label{fig:formatip}
\end{figure}
\begin{figure}[H]
    \centering
    \begin{tabular}{|c|c|} \hline
        \textbf{Opérateur} & \textbf{Description} \\ \hline
        : & range de ports \\
        ! & exception/négation \\
        $[$.., ..$]$ & groupement \\ \hline
    \end{tabular}
    \caption{Format de port acceptable dans le fichier de règles}
    \label{fig:formatport}
\end{figure}





\subsection{Fichier \textit{main.c}}



Il y a deux structures dans \textit{main.c}:
\begin{itemize}
    \item \textit{IdsArguments}, sert à stocker les paramètres donnés en ligne de commande à l'IDS,
    \item \textit{UserArgsPacketHandler}, sert à stocker des paramètres pour la fonction \textit{packet\_handler} tels que les règles du programme et les arguments de l'IDS lui-même.
\end{itemize}
Il y a aussi quelques fonctions à noter dans le fichier \textit{main.c}:
\begin{itemize}
    \item \textit{main}, c'est le point d'entrée du programme, elle va appeler les autres fonctions de l'ids,
    \item \textit{packet\_handler}, fonction appellée par \textit{pacp\_loop} quand un paquet est capturé, elle doit utiliser les fonctions \textit{populate\_packet} et \textit{rules\_matcher} pour vérifier si le paquet correspond à une règle,
    \item \textit{rules\_matcher}, vérifie si le paquet correspond à une règle,
    \item \textit{parse\_arguments}, analyse les arguments donnés en ligne de commande,
    \item \textit{write\_syslog}, écrit un message dans syslog.
\end{itemize}





\subsection{Détection de l’encryption du payload}



Dans la section \textit{critères minimum de réussite} de l'énoncé, il nous est demandé de pouvoir faire la \textit{détection de l'encryption du payload}. Cependant, c'est une tâche difficile si on doit le faire pour tous les paquets. D'autant plus que des données compressées ressemblent souvent à des données cryptées \cite{3}.

Ce que nous avons décidé de faire est donc de laisser l'utilisateur écrire des règles pour des protocoles de chiffrement des données comme TLS qui seront détectés en fonction du port (source ou destination) utilisé. Notre implémentation différe en deux points de la recommendation donnée (figure \ref{fig:tls01}):
\begin{enumerate}
    \item Nous ne cherchons pas à détecter la poignée de main TLS sur le port 443 car c'est le seul protocole qui utilise ce port \cite{5}, si un paquet est transmis avec ce port, il est directement signalé en tant que paquet utilisant TLS.
    \item Nous ne gardons pas trace de la communication en utilisant les numéro de séquence de paquet TCP mais nous utilisons uniquement le port utilisé. Ceci découle du point précédent, c-à-d qu'un paquet est signalé en fonction de son port, et puisque une communication utilisant TCP ou UDP ne peut pas changer de port car elle est identifiée en utilisant ces ports \cite{4}, il n'y a pas besoin de garder une trace de la communication avec une variable dans le code (le port utilisé est suffisant pour identifier la communication).
\end{enumerate}
Il y a deux problèmes à cette approche:
\begin{itemize}
    \item On imagine facilement que le protocole TLS peut être utilisé sur d'autres ports sans difficultés mais sa détection devient ardue puisqu'il faut dès lors chercher la présence de header TLS dans tous les paquets peut importe leur port. Ceci augmente aussi le risque de signalement de paquets n'utilisant pas le TLS. Nous avons décidé de ne pas prendre ce risque.
    \item On peut aussi penser que du traffic légitime passerait sur un port réservé au protocole TLS. Cependant, il y a peu de chance que cela arrive puisque le port est réservé.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{images/tls-01.PNG}
    \caption{Recommendation pour détecter et garder trace des paquets chiffrés}
    \label{fig:tls01}
\end{figure}










\section{Choix d'implémentation et problèmes rencontrés} \label{sec:implspec}





\subsection{Tokens} \label{subsec:tokens}



La tokenisation c'est la séparation d'un texte en plus petites unités appelées tokens (comme illustré sur la figure \ref{fig:tokenization}). L'utilité de la tokenisation dans ce projet est que l'on a séparé deux choses:
\begin{itemize}
    \item le traitement des informations contenues dans le texte,
    \item et la recherche des informations.
\end{itemize}
Ainsi, la fonction \textit{extract\_rules} (appellée par \textit{read\_rules} après la tokenisation) ne doit pas chercher où commence et finit un protocole dans le fichier de règle puisque ça a été pris en charge par la fonction \textit{tokenize\_rules}, elle est seulement responsable d'extraire l'information du token.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{images/tokenization.png}
    \caption{Illustration de la tokenisation \cite{6}}
    \label{fig:tokenization}
\end{figure}

Nous avons mis ci-dessous la fonction \textit{extract\_rules} utilisée dans notre code pour extraire les règles des tokens et les mettre dans des structures \textit{Rule}. La variable \textit{i} est utilisée pour itérer sur les tokens. Cependant il y a un problème : si une IP, par exemple, est en fait une liste d'IP qui est placée sur plusieurs tokens (voir figure \ref{fig:formatip} sur les formats d'IP), de combien doit-on incrémenter la variable \textit{i} ?

Pour résoudre ce problème, le pointeur de la variable \textit{i} est passé en paramètre des fonctions qui servent à obtenir la règle (comme \textit{get\_rule\_action} ou \textit{get\_rule\_source\_ip}). Ce sont désormais ces fonctions qui sont responsables d'incrémenter \textit{i}. Ainsi, si une liste d'IP source prend vingt tokens, la fonction \textit{get\_rule\_source\_ip} devra incrémenter \textit{i} de vingt.
\begin{lstlisting}[style=CStyle]
void extract_rules(Rule **rules_ptr, int *nb_rules, Tokens *tokens) {
    int i = 0;
    while (i < tokens->nb_tokens) {
        // add an empty rule to the list
        ...

        // initialize the rule
        ...

        // get the rule
        get_rule_action(rule, tokens, &i);
        get_rule_protocol(rule, tokens, &i);
        get_rule_source_ip(rule, tokens, &i);
        get_rule_source_port(rule, tokens, &i);
        get_rule_direction(rule, tokens, &i);
        get_rule_destination_ip(rule, tokens, &i);
        get_rule_destination_port(rule, tokens, &i);
        get_rule_options(rule, tokens, &i);

        // NOTE: no need to increase i (i++) as it is incremented in the
        // functions used above
    }
}
\end{lstlisting}





\subsection{Structures de données dynamiques}



%% - expliquer les fonctions "increase_nb_..."





\subsection{Problèmes d'endianness}



%% - expliquer les fonctions qui changent l'endianness





\subsection{Structures pour header de protocole}



%% - expliquer le problème avec les structures (tester: __attribute__)





\subsection{Passer des arguments à la fonction \textit{packet\_handler}}



%% - expliquer la structure "UserArgsPacketHandler"





\subsection{Fonctions récursives}



%% - expliquer les fonctions récursives





\subsection{Macros et masques}



%% - expliquer les macros avec les masques





\subsection{...}



%% - expliquer les endroits où j'ai utiliser un shift de bits (<<)
%%   https://stackoverflow.com/questions/45432694/shifting-unsigned-int-more-than-the-size-of-it-undefined-or-not





\subsection{Variable statique}



%% - expliquer la variable statique ("Packet n°...")





\subsection{...}



%% - expliquer quand on additionne au pointeur "n" ou "n * sizeof(...)" (=> double pointeur ??) (rules.c)










\section{Améliorations possibles}



%%
%% -- prendre en charge les adresses des protocoles ipv6/ethernet
%% -- pouvoir pointer la ligne & colonne où il y a une erreur dans le fichier ids.rules
%% -- ajouter la possibilité d'écrire des commentaires dans le fichier ids.rules
%% -- pouvoir "drop" le paquet sans qu'il soit analysé par un programme
%%    https://www.linuxquestions.org/questions/linux-networking-3/capture-drop-packets-using-c-716868/
%% -- pouvoir "reject" le paquet (drop + envoyer un message "RST/ICMP unreach error")
%% --  Some organizations have a policy that states that SSL/TLS encrypted data needs to be decrypted when it reaches the internal network and then analyzed for malware and potential attacks. It is often then re-encrypted and sent to its final destination.
%%    https://qr.ae/pNJyLS
%% -- voir les critères de dépassement de l'énoncé
%% -- afficher une erreur quand on donne un mauvais argument à l'ids (voir afficher l'aide)
%% -- ajouter plus de fichiers .c/.h pour que ce soit plus simple (ex: 1 seule enum pour les protocoles)
%%










\section{Conclusion}



%%















\newpage \tableofcontents \listoffigures
\begin{thebibliography}{9}
\bibitem{1} {\small \url{https://github.com/groumache/Intrusion-Detection-System}}
\bibitem{2} {\small \url{https://suricata.readthedocs.io/en/latest/rules/intro.html}}
\bibitem{3} {\small \url{https://qr.ae/pNSWwR}}
\bibitem{4} {\small \url{https://stackoverflow.com/a/16268404/10524378}}
\bibitem{5} {\small \url{https://fr.wikipedia.org/wiki/Liste_de_ports_logiciels}}
\bibitem{6} {\small \url{https://www.seas.upenn.edu/~cis522/lecture_notes/lec11.pdf}}
\end{thebibliography}




















\end{document}
